# Vite CSS Modules 配置详解

在 `vite.config.js` 中，我们通过 `css.modules` 属性来控制 Vite 对 CSS Modules 的处理行为。

## 完整配置示例

```javascript
// vite.base.config.js
import { defineConfig } from "vite";

export default defineConfig({
    envPrefix: 'ENV',
    css: {
        modules: {
            localsConvention: 'camelCase',
            scopeBehaviour: 'local',
            generateScopedName: '[name]__[local]__[hash:base64:5]',
            hashPrefix: "hello",
            globalModulePaths: ['./componentB.module.css'],
        }
    }
})
```

## 配置项详解

### 1. localsConvention

**作用：** 修改生成的配置对象中 key 的展示形式

**可选值：**
- `'camelCase'`：将 kebab-case 转换为 camelCase（如：`footer-content` → `footerContent`）
- `'dashes'`：保留连字符，但允许驼峰命名访问
- `'only'`：只保留原始类名
- `'camelCaseOnly'`：只允许驼峰命名访问，不保留原始类名

**实际效果：**
```css
/* componentA.module.css */
.footer-content {
    background-color: yellow;
}
```

```javascript
// 使用 localsConvention: 'camelCase' 后
import styles from './componentA.module.css'
console.log(styles.footerContent) // 可以用驼峰方式访问
```

### 2. scopeBehaviour

**作用：** 配置当前的模块化行为是模块化还是全局化

**可选值：**
- `'local'`：默认值，所有类名都会被模块化处理（生成唯一hash）
- `'global'`：所有类名都保持全局，不进行模块化处理
- `'pure'`：只有被 `:local()` 包装的类名才会被模块化

**说明：** 有 hash 就是开启了模块化的标志，因为它可以保证产生不同的 hash 值来控制样式类名不被覆盖。

### 3. generateScopedName

**作用：** 定义生成类名的规则

**配置方式：**
- **字符串模板**：`'[name]__[local]__[hash:base64:5]'`
- **函数形式**：
```javascript
generateScopedName: (name, filename, css) => {
    console.log('name', name)       // 原始类名
    console.log('filename', filename) // 文件名
    console.log('css', css)         // CSS内容
    return `custom__${name}__${Math.random().toString(36).slice(2, 15)}`
}
```

**模板占位符：**
- `[name]`：CSS 文件名（不含扩展名）
- `[local]`：原始类名
- `[hash:base64:5]`：5位 base64 编码的哈希值

**生成效果：** `componentA__footer__a1b2c`

### 4. hashPrefix

**作用：** 为生成的哈希值添加自定义前缀

**原理：** 生成 hash 会根据你的类名 + 文件名 + 内部随机字符串进行生成。如果你想要生成的 hash 更加独特，可以配置 `hashPrefix`。

**Hash 特性：**
- 只要字符串有一个字符不一样，生成的 hash 就完全不一样
- 只要字符串完全一样，生成的 hash 就会一样

**配置示例：**
```javascript
hashPrefix: "hello"
```

### 5. globalModulePaths

**作用：** 指定不想参与 CSS 模块化的路径

**使用场景：**
- 某些组件样式需要保持原始类名
- 便于第三方库或全局样式覆盖
- 过渡期间部分文件暂时不使用 CSS Modules

**配置示例：**
```javascript
globalModulePaths: ['./componentB.module.css']
```

**效果：** `componentB.module.css` 中的类名将保持原样，不会被哈希化。

## 项目中的实际应用

### CSS 模块文件结构
```
test-vite/
├── componentA.module.css    # 启用模块化
├── componentB.module.css    # 配置为全局模式
├── index.module.less        # Less + 模块化
└── index.css               # 普通全局样式
```

### 使用示例

**componentA.js**：
```javascript
import componentA from "./componentA.module.css"
console.log('componentA', componentA) 
// 输出：{ footer: "componentA__footer__a1b2c", footerContent: "componentA__footer-content__x9y8z" }

const div = document.createElement("div")
div.className = componentA.footer // 使用模块化类名
```

**componentB.js**：
```javascript
import componentB from "./componentB.module.css"
console.log('componentB', componentB)
// 由于配置了 globalModulePaths，输出：{ footer: "footer" }

const div = document.createElement("div")
div.className = componentB.footer // 使用原始类名
```