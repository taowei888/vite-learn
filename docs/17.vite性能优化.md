# Vite 性能优化指南

性能优化通常包含以下几个层面的内容：

## 1. 开发时构建速度优化

### Webpack vs Vite 的构建策略

- **Webpack 的优化手段**：
  - `cache-loader`：缓存 loader 结果，如果两次构建源代码没有变化，则直接使用缓存，不调用 Loader
  - `thread-loader`：开启多线程构建
  
- **Vite 的优势**：
  - 采用按需加载策略，开发环境启动速度极快
  - 基于 ES Modules，无需打包即可运行

## 2. 页面性能指标优化

页面性能直接关系到用户体验，主要关注以下指标：

### 首屏渲染优化

- **FCP (First Contentful Paint)**：页面中第一个元素的渲染时长
- **LCP (Largest Contentful Paint)**：页面中最大元素的渲染时长
- **懒加载**：按需加载资源，减少首屏加载时间

### HTTP 缓存优化

#### 强缓存
- 服务端在响应头中添加 `expires` 等字段
- 客户端记住这些字段，在过期时间之前直接从缓存读取，不发起网络请求

#### 协商缓存
- 客户端向服务端发送协商请求，询问资源是否更新
- 如果资源未更新，服务端返回 304 状态码
- 如果资源已更新，服务端返回新的资源内容

## 3. React 组件性能优化

### 副作用清理

组件频繁挂载和卸载时，必须注意清理副作用：

```javascript
const [timer, setTimer] = useState(null);

useEffect(() => {
  const timerId = setTimeout(() => {
    // 定时器逻辑
  }, 1000);
  
  setTimer(timerId);
  
  // 清理函数
  return () => {
    if (timerId) {
      clearTimeout(timerId);
    }
  };
}, []);
```

### 浏览器 API 优化

- **requestAnimationFrame**：与浏览器刷新频率同步，优化动画性能
- **requestIdleCallback**：在浏览器空闲时执行任务
  - 浏览器帧率：16.6ms 更新一次（执行 JS 逻辑、重排重绘等）
  - 如果 JS 执行时间超过 16.6ms，会导致掉帧
  - React Concurrent Mode 利用时间切片，实现可中断渲染

### JavaScript 性能优化

#### 防抖节流
使用 lodash 等工具库实现防抖节流，避免频繁触发事件处理函数。

#### 循环优化
```javascript
// 推荐写法：缓存数组长度，避免重复计算
const arr = [1, 2, 3];
for (let i = 0, len = arr.length; i < len; i++) {
  // 处理逻辑
}

// 大数据量处理时，优先使用 lodash.forEach 而非原生 forEach
const largeArray = []; // 几千条数据
// 避免：largeArray.forEach()
// 推荐：_.forEach(largeArray, callback)
```

## 4. CSS 性能优化

- **继承属性优化**：充分利用 CSS 继承，避免重复设置相同属性
- **避免深层嵌套**：减少 CSS 选择器的嵌套层级，提高渲染性能

## 5. 构建优化

### Vite (Rollup) / Webpack 构建优化

- **体积优化**：
  - 代码压缩（minification）
  - Tree Shaking：移除未使用的代码
  - 图片资源压缩
  - CDN 加载：将静态资源部署到 CDN
  - 代码分包（Code Splitting）：按需加载，减少初始包体积

---

通过以上优化手段，可以显著提升应用的开发体验和用户体验。在实际项目中，需要根据具体场景选择合适的优化策略。